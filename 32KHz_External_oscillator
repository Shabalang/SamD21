uint32_t periCk[33] = {GCLK_CLKCTRL_ID_WDT, GCLK_CLKCTRL_ID_RTC, 
	GCLK_CLKCTRL_ID_EIC, GCLK_CLKCTRL_ID_EVSYS_0, 
	GCLK_CLKCTRL_ID_EVSYS_1, GCLK_CLKCTRL_ID_EVSYS_2,
	GCLK_CLKCTRL_ID_EVSYS_3, GCLK_CLKCTRL_ID_EVSYS_4, 
	GCLK_CLKCTRL_ID_EVSYS_5, GCLK_CLKCTRL_ID_EVSYS_6, 
	GCLK_CLKCTRL_ID_EVSYS_7, GCLK_CLKCTRL_ID_EVSYS_8,
	GCLK_CLKCTRL_ID_EVSYS_9, GCLK_CLKCTRL_ID_EVSYS_10, 
	GCLK_CLKCTRL_ID_EVSYS_11, GCLK_CLKCTRL_ID_SERCOMX_SLOW, 
	GCLK_CLKCTRL_ID_SERCOM0_CORE, GCLK_CLKCTRL_ID_SERCOM1_CORE, 
	GCLK_CLKCTRL_ID_SERCOM2_CORE, GCLK_CLKCTRL_ID_SERCOM3_CORE, 
	GCLK_CLKCTRL_ID_SERCOM4_CORE, GCLK_CLKCTRL_ID_SERCOM5_CORE, 
	GCLK_CLKCTRL_ID_TCC0_TCC1, GCLK_CLKCTRL_ID_TCC2_TC3,
	GCLK_CLKCTRL_ID_TC4_TC5, GCLK_CLKCTRL_ID_TC6_TC7, 
	GCLK_CLKCTRL_ID_ADC, GCLK_CLKCTRL_ID_AC_DIG, 
	GCLK_CLKCTRL_ID_AC_ANA, GCLK_CLKCTRL_ID_DAC,
	GCLK_CLKCTRL_ID_PTC, GCLK_CLKCTRL_ID_I2S_0, GCLK_CLKCTRL_ID_I2S_1
  };
  void sysClkGenwithDPLL (void)
{
	uint32_t k;
// Configure XOSC32K parameters and wait until it is ready	
	REG_SYSCTRL_XOSC32K = SYSCTRL_XOSC32K_STARTUP(0x6) +	
		SYSCTRL_XOSC32K_RUNSTDBY + SYSCTRL_XOSC32K_AAMPEN +
		SYSCTRL_XOSC32K_EN32K + SYSCTRL_XOSC32K_XTALEN;
	REG_SYSCTRL_XOSC32K |= SYSCTRL_XOSC32K_ENABLE; // set ENABLE bit
	while(!(REG_SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_XOSC32KRDY));
// Configure generic clock generator 2 to 32 kHz (use XOSC32K as source)
	REG_GCLK_GENDIV = GCLK_GENDIV_DIV(0) + GCLK_GENDIV_ID(2);
	REG_GCLK_GENCTRL = GCLK_GENCTRL_RUNSTDBY + GCLK_GENCTRL_IDC +
		GCLK_GENCTRL_GENEN + GCLK_GENCTRL_SRC_XOSC32K + GCLK_GENCTRL_ID(0x2);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);
// Use generic clock generator 2 to generate GCLK_DPLL_32K—locking clock
	REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK2 + GCLK_CLKCTRL_ID_FDPLL32K;
// use FDPLL96M to generate 48 MHz output and use XOSC32K as its reference clock
	REG_SYSCTRL_DPLLRATIO	= 	SYSCTRL_DPLLRATIO_LDRFRAC(13) +  SYSCTRL_DPLLRATIO_LDR(48000000/32768);
	REG_SYSCTRL_DPLLCTRLB	= 	SYSCTRL_DPLLCTRLB_REFCLK(0)+ 
	   	SYSCTRL_DPLLCTRLB_FILTER(SYSCTRL_DPLLCTRLB_FILTER_DEFAULT);
	REG_SYSCTRL_DPLLCTRLA	=  	SYSCTRL_DPLLCTRLA_RUNSTDBY + 
					SYSCTRL_DPLLCTRLA_ENABLE; 
	while(!(REG_SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_DPLLLCKR)); // wait until FDPLL96M locks
// Configure generic clock generator 0--Set GCLK_MAIN to 48 MHz
	REG_GCLK_GENDIV 		= 	GCLK_GENDIV_DIV(0) + GCLK_GENDIV_ID(0);
	REG_GCLK_GENCTRL 		= 	GCLK_GENCTRL_RUNSTDBY + GCLK_GENCTRL_IDC +
					GCLK_GENCTRL_GENEN + GCLK_GENCTRL_SRC_FDPLL + 
					GCLK_GENCTRL_ID(0x0);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);
  // Configure generic clock generator 1—GCLKGEN[1] frequency set to 24MHz
	REG_GCLK_GENDIV 	= 	GCLK_GENDIV_DIV(0) + GCLK_GENDIV_ID(1); 
	REG_GCLK_GENCTRL 	= 	GCLK_GENCTRL_RUNSTDBY +  GCLK_GENCTRL_DIVSEL + 
				GCLK_GENCTRL_IDC + GCLK_GENCTRL_GENEN + 
				GCLK_GENCTRL_SRC_FDPLL + GCLK_GENCTRL_ID(0x1);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);

// use generic clock generator 0 to generate generic clock for USB (48 MHz)
	REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK0 +
			GCLK_CLKCTRL_ID_USB;
// use generic clock generator 1 to generate generic clocks for all other peripherals
	for(k = 0; k < 33; k++) {
		REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK1 + periCk[k];
	}
  // set CPUDIV, APBADIV, APBBDIV, APBCDIV to 2, 2, 2, 2
	REG_PM_CPUSEL 	= PM_CPUSEL_CPUDIV_DIV2;
	REG_PM_APBASEL 	= PM_APBASEL_APBADIV_DIV2;
	REG_PM_APBBSEL 	= PM_APBBSEL_APBBDIV_DIV2;
	REG_PM_APBCSEL 	= PM_APBCSEL_APBCDIV_DIV2;
	while(!(REG_PM_INTFLAG & PM_INTFLAG_CKRDY)); // wait until the divided clock are 
				// effective enable synchronous clocks to peripherals
	REG_PM_AHBMASK	= 0x7F; // enable synchronous clocks for USB, DMAC, NVMCTRL, 					// DSU, HPB2~HPB0
	REG_PM_APBAMASK	= 0x7F; 	// enable synchronous clocks for EIC, RTC, WDT, GCLK, 					// SYSCTRL, PM, PAC0
	REG_PM_APBBMASK	= 0x3F; 	// enable synchronous clocks for USB, DMAC, PORT, 					// NVMCTRL, DSU, PAC1
	REG_PM_APBCMASK	= 0x3FFFFF; // enable synchronous clocks for AC1, I2S, PTC, DAC, 					// AC, ADC, TC7~TCC0, SERCOM5~SERCOM0, EVSYS, PAC2
}

