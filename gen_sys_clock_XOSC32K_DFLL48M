/* generates system clock with XOSC32K and DFLL48M as the clock sources
   Sets CPU and all peripheral clocks, synchronous and asynchronous, to 24 MHz
*/
uint32_t periCk[33] = {GCLK_CLKCTRL_ID_WDT, GCLK_CLKCTRL_ID_RTC, GCLK_CLKCTRL_ID_EIC,
	GCLK_CLKCTRL_ID_EVSYS_0, GCLK_CLKCTRL_ID_EVSYS_1, GCLK_CLKCTRL_ID_EVSYS_2,
	GCLK_CLKCTRL_ID_EVSYS_3, GCLK_CLKCTRL_ID_EVSYS_4, GCLK_CLKCTRL_ID_EVSYS_5,
	GCLK_CLKCTRL_ID_EVSYS_6, GCLK_CLKCTRL_ID_EVSYS_7, GCLK_CLKCTRL_ID_EVSYS_8,
	GCLK_CLKCTRL_ID_EVSYS_9, GCLK_CLKCTRL_ID_EVSYS_10, GCLK_CLKCTRL_ID_EVSYS_11,
	GCLK_CLKCTRL_ID_SERCOMX_SLOW, GCLK_CLKCTRL_ID_SERCOM0_CORE, 	GCLK_CLKCTRL_ID_SERCOM1_CORE,
	GCLK_CLKCTRL_ID_SERCOM2_CORE, GCLK_CLKCTRL_ID_SERCOM3_CORE, 	GCLK_CLKCTRL_ID_SERCOM4_CORE,
	GCLK_CLKCTRL_ID_SERCOM5_CORE, GCLK_CLKCTRL_ID_TCC0_TCC1, 	GCLK_CLKCTRL_ID_TCC2_TC3,
	GCLK_CLKCTRL_ID_TC4_TC5, GCLK_CLKCTRL_ID_TC6_TC7, GCLK_CLKCTRL_ID_ADC,
	GCLK_CLKCTRL_ID_AC_DIG, GCLK_CLKCTRL_ID_AC_ANA, GCLK_CLKCTRL_ID_DAC,
	GCLK_CLKCTRL_ID_PTC, GCLK_CLKCTRL_ID_I2S_0, GCLK_CLKCTRL_ID_I2S_1
  };
  void sysClkGenwithDFLL (void)
{
	uint32_t k, temp1, temp2;
// Configure XOSC32K parameters and wait until it is ready
	REG_SYSCTRL_XOSC32K = SYSCTRL_XOSC32K_STARTUP(0x6) +
		SYSCTRL_XOSC32K_RUNSTDBY + SYSCTRL_XOSC32K_AAMPEN +
		SYSCTRL_XOSC32K_EN32K + SYSCTRL_XOSC32K_XTALEN;
	REG_SYSCTRL_XOSC32K |= SYSCTRL_XOSC32K_ENABLE; // set ENABLE bit
	while(!(REG_SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_XOSC32KRDY));
// Configure generic clock generator 2 (GCLKGEN[2]) to 32 kHz (use XOSC32K as source)
	REG_GCLK_GENDIV = GCLK_GENDIV_DIV(1) + GCLK_GENDIV_ID(2);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);
	REG_GCLK_GENCTRL = GCLK_GENCTRL_RUNSTDBY + GCLK_GENCTRL_IDC +
	GCLK_GENCTRL_GENEN + GCLK_GENCTRL_SRC_XOSC32K + GCLK_GENCTRL_ID(0x2);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);
// use generic clock generator 2 to generate GCLK_DFLL48M_REF
	REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK2 + GCLK_CLKCTRL_ID_DFLL48;
  // use DFLL48M to generate 48 MHz output and use XOSC32K as its reference clock
	temp1 = (*(uint32_t *)0x806024)&(0x3F << 26);
	temp1 = temp1 >> 26;
	temp2 = (*(uint32_t *)0x806028)&(0x3FF);
	REG_SYSCTRL_DFLLVAL = (temp1 << 10) + temp2;
// CSTEP = COARSE/4; FSTEP = FINE/4
	REG_SYSCTRL_DFLLMUL = SYSCTRL_DFLLMUL_CSTEP(0x1F/4) + 
				SYSCTRL_DFLLMUL_FSTEP(0xFF/4)+ (48000000/32768);
	REG_SYSCTRL_DFLLCTRL = SYSCTRL_DFLLCTRL_RUNSTDBY + SYSCTRL_DFLLCTRL_LLAW +
		SYSCTRL_DFLLCTRL_MODE + SYSCTRL_DFLLCTRL_ENABLE;
	while(!(REG_SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_DFLLRDY)); // wait until DFLL48M locks
// Configure generic clock generator 0—set GCLK_MAIN to 48 MHz
	REG_GCLK_GENDIV = GCLK_GENDIV_DIV(1) + GCLK_GENDIV_ID(0); 
	REG_GCLK_GENCTRL = GCLK_GENCTRL_RUNSTDBY + GCLK_GENCTRL_IDC +
		GCLK_GENCTRL_GENEN + GCLK_GENCTRL_SRC_DFLL48M + GCLK_GENCTRL_ID(0x0);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);
  // Configure generic clock generator 1—set frequency to 24 MHz
	REG_GCLK_GENDIV = GCLK_GENDIV_DIV(0) + GCLK_GENDIV_ID(1); 
	REG_GCLK_GENCTRL = GCLK_GENCTRL_RUNSTDBY +  GCLK_GENCTRL_DIVSEL +  GCLK_GENCTRL_IDC + GCLK_GENCTRL_GENEN + GCLK_GENCTRL_SRC_DFLL48M + 
		GCLK_GENCTRL_ID(0x1);
	while (REG_GCLK_STATUS & GCLK_STATUS_SYNCBUSY);

// use generic clock generator 0 to generate generic clock for USB (48 MHz)
	REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK0 +
		GCLK_CLKCTRL_ID_USB;
// use generic clock generator 1 to generate generic clocks for all other peripherals
	for(k = 0; k < 33; k++) {
		REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN + GCLK_CLKCTRL_GEN_GCLK1 +
				periCk[k];
	}
  // set CPUDIV, APBADIV, APBBDIV, APBCDIV to 2, 2, 2, 2
	REG_PM_CPUSEL 	= PM_CPUSEL_CPUDIV_DIV2;
	REG_PM_APBASEL 	= PM_APBASEL_APBADIV_DIV2;
	REG_PM_APBBSEL 	= PM_APBBSEL_APBBDIV_DIV2;
	REG_PM_APBCSEL 	= PM_APBCSEL_APBCDIV_DIV2;
	while(!(REG_PM_INTFLAG & PM_INTFLAG_CKRDY)); // wait until the divided clock are effective
// enable synchronous clocks for USB, DMAC, NVMCTRL, DSU, HPB2~HPB0
	REG_PM_AHBMASK= 0x7F; 
// enable synchronous clocks for EIC, RTC, WDT, GCLK, SYSCTRL, PM, PAC0
	REG_PM_APBAMASK = 0x7F; 
// enable synchronous clocks for USB, DMAC, PORT, NVMCTRL, DSU, PAC1
	REG_PM_APBBMASK= 0x3F; 
// enable synchronous clocks for AC1, I2S, PTC, DAC, AC, ADC, TC7~TCC0, SERCOM5~SERCOM0, 
// EVSYS, PAC2
	REG_PM_APBCMASK = 0x3FFFFF; 
}



